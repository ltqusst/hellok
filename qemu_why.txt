* simple code segement comment is useless.
* framework summary + code reference are fine

================================================
how simulation of serial port is done?
	
	search "-serial" in "qemu-options.def"
	hardware simulator must simulate registers, and perform the real job by some service provided by host OS(linux), the backends can be specified using -serial option.

	search QEMU_OPTION_serial in vl.c: 
		simply respond by add_device_config(DEV_SERIAL, optarg);
		
	search DEV_SERIAL in vl.c: 
		later foreach_device_config(DEV_SERIAL, serial_parse);
		
	search serial_parse in vl.c: 
		call qemu_chr_new() create a host device
		the cmdline from device_config is considered as a devname that qemu_chr_new() knows.
		the created device is stored in serial_hds[];
		
	qemu_chr_parse_compat() create a opts(option set):
				.id   serial%d
				opt(
					backend: 	string value inferred from command line -serial xxx
					path: 		string value inferred from finlename
					).
				
	qemu_chr_new_from_opts() search through backend char drivers for with name equal to specified "backend" opt generated by 
	above qemu_chr_parse_compat() function. if found, create a backend instance and call the driver's parse() callback.
	and finally call qmp_chardev_add() to create the CharDriverState * chr, for pty, it will call linux system api openpty()
	to get pty and register some read/write op with it.
	
	qemu_chr_fe_write_all(): we can find lot of simulated device call this function to do the job, this function will 
	pass the call on to the backend CharDriverState * chr to do the real job.
	
	TYPE_DIGIC_UART
	TYPE_LM32_JUART
	TYPE_MILKYMIST_UART
	digic_uart_write, line 78:  qemu_chr_fe_write_all(s->chr, &ch, 1);
================================================
backend char driver
	register_types() will be called as constructor, here lot of backend driver registered into GSList * backends;
	the driver item have: 
		name("socket","udp","file","tty","stdio","pty","pipe","console"...)
		kind(CHARDEV_BACKEND_KIND_XXX)
		parse(a callback function that 
================================================
qemu Object model
	include/qom/object.h
		
================================================
QEMUMachine/MachineClass
	
	about PC architecture:
		http://en.wikipedia.org/wiki/Northbridge_(computing)
		http://en.wikipedia.org/wiki/Southbridge_(computing)
		http://en.wikipedia.org/wiki/Low_Pin_Count
		http://en.wikipedia.org/wiki/Industry_Standard_Architecture
		
	boards.h defines the board level simulation model.
	/hw/i386/pc_piix.c:
		* pc_machine_init() is module constructor in file it register lots of available pc machine(virtual machine)
		* pc_init1() is core code to create any virtual machine of i386 pc type
		*	pc_basic_device_init() create lot of basic(slow) peripheral device connected to ISA bus 
		  including RTC, COM, Parallel, ps2_mouse, floopy.
			- call serial_isa_init() : 
				create TYPE_ISA_SERIAL DeviceState * dev with prop "chrdev" equal to chr from serial_hds[]
				the (*class_init)() function serial_isa_class_initfn() of this dev will be called.
			- serial_isa_class_initfn():
			  call memory_region_init_io() to register it's memory access interface: serial_io_ops
			  this interface is how CPU's command/data routed to the real simulated implementation.
			  
================================================
The core configuration data structure: QemuOptsList *vm_config_groups[32];	

	* a virtual machine's whole internal configuration is represented by this data structure.
	  - see qemu_read_config_file() & qemu_read_default_config_files();
	        the whole config is build upon Opts.
	  - see vl.c:main(), entire opts internal representation build from command line args. 
	
	vl.c:main() the very first thing main() does is call qemu_add_opts() to build-up opts group entry(QemuOptsList).
	currently total 31 opts group.
	Opts,OptsList is a string structured option parameter(Opt);
	
	the implementation is complex and urgly, but the function it provides is very clean,flexible and usefull.
	caller can access opt by group:id:name, it's like a dictionary of all options for a virtual machine, including
	front/backend configuration.
	
	the last list item of vm_config_groups[31] is reserved as NULL guard.
		name: 				drive, chardev, device, netdev, ...
		implied_opt_name:	
		head:				this is a list head of QemuOpts
							QemuOpts:can be viewed as a option set
								.id:		a string name for opts
								.list:	parent QemuOptsList pointer
								.loc:	
								.head:	a list head of QemuOpt
								
								qemu_opts_create(list,id,...):	
									create from list parent and an identifier string
								
								
								qemu_opt_find(opts, name): 		
									search opt in this list
								qemu_opt_set(opts, name):  
									create new opt entry in opts, 
								qemu_opt_get(opts, name):  
									retrieve str value, given opt name(if no such opt, default is returned from list->desc)
								qemu_opt_get_bool(opts, name):  
								qemu_opt_get_size(opts, name):  
								qemu_opt_get_number(opts, name):  
									bool :"on","off"
									size : xxb/K/M/G/T ...
									number: 1234...
							QemuOpt:
								.name:	a string name of the option
								.str:	a string value, the configuration parameter
								.desc:	a reference to the descriptor of the name/type/help/default
								.value:	bool/uint value of parameter
								.opts:	parent opts
		desc:				a const list of opt name/type/help/default
							a opt is an config option for a module.
	QemuOpt
	
	once these information are added into vm_config_groups[], they are managed as a database of the system.
	any code can search an opt by group:id pair:
		call qemu_find_opts(group) to get list of given group;
		call qemu_opts_find(list, id) to get QemuOpts pointer of given id 
	id is unique string in a list is it's created by call qemu_opts_create();
	
	
	qemu_opt_find
	
================================================
device_config: 
	the device here is the host device used to do the simulation backend job, not the device simulated for target.
	type: 		very general device category(not specific model)
	cmdline: 	a string describe what Host device will be used
	loc:		where this config originate.
	
	qemu_chr_new
================================================
Opt pasring:
lookup_opt() translate opts from argv[]
	(qemu_options, each entry is l)

qemu_options
	name(xxx of the -xxx or --xxx)
	flags(0x0001: have arg)
	index(the corresponding enum used by code)

#include "qemu-options-wrapper.h"	
	a special way to define opt:
		1.using C preprocessor
		  DEF(option, opt_arg, opt_enum, opt_help, arch_mask) 
		2.integrate all information into single file
		   #include "qemu-options.def"


			