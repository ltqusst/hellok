* simple code segement comment is useless.
* framework summary + code reference are fine

================================================
how simulation of serial port is done?
	
	search "-serial" in "qemu-options.def"
	hardware simulator must simulate registers, and perform the real job by some service provided by host OS(linux), the backends can be specified using -serial option.

	search QEMU_OPTION_serial in vl.c: 
		simply respond by add_device_config(DEV_SERIAL, optarg);
	search DEV_SERIAL in vl.c: 
		later foreach_device_config(DEV_SERIAL, serial_parse);
	search serial_parse in vl.c: 
		call qemu_chr_new() create a host device
		the cmdline from device_config is considered as a devname that qemu_chr_new() knows.
		the created device is stored in 
	qemu_chr_parse_compat() create a opts(option set):
				.id   serial%d
				opt(
					backend: 	string value inferred from command line -serial xxx
					path: 		string value inferred from finlename
					).
				
	qemu_chr_new_from_opts() search through backend char drivers for with name equal to specified "backend" opt generated by 
	above qemu_chr_parse_compat() function. if found, create a backend instance and call the driver's parse() callback.
	and finally call qmp_chardev_add() to create the CharDriverState * chr, for pty, it will call linux system api openpty()
	to get pty and register some read/write op with it.
	
	qemu_chr_fe_write_all(): we can find lot of simulated device call this function to do the job, this function will 
	pass the call on to the backend CharDriverState * chr to do the real job.
	
	digic_uart_write, line 78:  qemu_chr_fe_write_all(s->chr, &ch, 1);
================================================
backend char driver
	register_types() will be called as constructor, here lot of backend driver registered into GSList * backends;
	the driver item have: 
		name("socket","udp","file","tty","stdio","pty","pipe","console"...)
		kind(CHARDEV_BACKEND_KIND_XXX)
		parse(a callback function 
================================================	
QemuOptsList *vm_config_groups[32];	
	search qemu_add_opts() in whole project.
	there are currently total 31 option category.each category ave a QemuOptsList;
		
	Opts,OptsList is a string structured option parameter(Opt);
	basically for easy access & maintain.
	
	the last list item of vm_config_groups[31] is reserved as NULL guard.
		name: 				drive, chardev, device, netdev, ...
		implied_opt_name:	
		head:				this is a list head of QemuOpts
							QemuOpts:can be viewed as a option set
								.id:		a string name for opts
								.list:	parent QemuOptsList pointer
								.loc:	
								.head:	a list head of QemuOpt
								
								qemu_opts_create(list,id,...):	
									create from list parent and an identifier string
								
								
								qemu_opt_find(opts, name): 		
									search opt in this list
								qemu_opt_set(opts, name):  
									create new opt entry in opts, 
								qemu_opt_get(opts, name):  
									retrieve str value, given opt name(if no such opt, default is returned from list->desc)
								qemu_opt_get_bool(opts, name):  
								qemu_opt_get_size(opts, name):  
								qemu_opt_get_number(opts, name):  
									bool :"on","off"
									size : xxb/K/M/G/T ...
									number: 1234...
							QemuOpt:
								.name:	a string name of the option
								.str:	a string value, the configuration parameter
								.desc:	a reference to the descriptor of the name/type/help/default
								.value:	bool/uint value of parameter
								.opts:	parent opts
		desc:				a const list of opt name/type/help/default
							a opt is an config option for a module.
	QemuOpt
	
	once these information are added into vm_config_groups[], they are managed as a database of the system.
	any code can search an opt by group:id pair:
		call qemu_find_opts(group) to get list of given group;
		call qemu_opts_find(list, id) to get QemuOpts pointer of given id 
	id is unique string in a list is it's created by call qemu_opts_create();
	
	
	qemu_opt_find
	
================================================
device_config: 
	the device here is the host device used to do the simulation backend job, not the device simulated for target.
	type: 		very general device category(not specific model)
	cmdline: 	a string describe what Host device will be used
	loc:		where this config originate.
	
	qemu_chr_new
================================================
Opt pasring:
lookup_opt() translate opts from argv[]
	(qemu_options, each entry is l)

qemu_options
	name(xxx of the -xxx or --xxx)
	flags(0x0001: have arg)
	index(the corresponding enum used by code)

#include "qemu-options-wrapper.h"	
	a special way to define opt:
		1.using C preprocessor
		  DEF(option, opt_arg, opt_enum, opt_help, arch_mask) 
		2.integrate all information into single file
		   #include "qemu-options.def"


			